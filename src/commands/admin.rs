use poise::serenity_prelude as serenity;
use tracing::info;

use crate::levels::user_level::UserLevel;
use crate::levels::xp;
use crate::Data;

type Error = Box<dyn std::error::Error + Send + Sync>;
type Context<'a> = poise::Context<'a, Data, Error>;

#[allow(dead_code)]
async fn is_admin(ctx: Context<'_>, member: serenity::PartialMember) -> Result<bool, Error> {
    Ok(member.roles.iter().any(|r| {
        r.to_role_cached(ctx).map_or(false, |r| {
            r.has_permission(serenity::Permissions::ADMINISTRATOR)
        })
    }))
}

#[poise::command(
    prefix_command,
    slash_command,
    subcommands("set_pub", "set_user", "spam_delay", "min_xp_gain", "max_xp_gain"),
    required_permissions = "ADMINISTRATOR",
    category = "Admin"
)]
pub async fn admin(_ctx: Context<'_>) -> Result<(), Error> {
    Ok(())
}

#[poise::command(prefix_command, slash_command, category = "Admin")]
pub async fn set_pub(
    ctx: Context<'_>,
    #[description = "The channel to set to public"] channel: serenity::ChannelId,
) -> Result<(), Error> {
    let guild_id = if let Some(id) = ctx.guild_id() {
        id.0
    } else {
        ctx.say("Must be in guild").await?;
        return Ok(());
    };
    let channel_id = channel.0;

    ctx.data()
        .db
        .set_pub_channel_id(channel_id, guild_id)
        .await?;

    info!("Channel {channel_id} set to pub for guild {guild_id}");

    ctx.say(format!(
        "{} is the new pub",
        channel.name(ctx).await.unwrap()
    ))
    .await?;

    Ok(())
}

#[poise::command(prefix_command, slash_command, category = "Admin")]
pub async fn set_user(
    ctx: Context<'_>,
    #[description = "User to modify"] user: serenity::UserId,
    #[description = "Amount of Xp"] xp: i64,
) -> Result<(), Error> {
    let guild_id = if let Some(id) = ctx.guild_id() {
        id.0
    } else {
        ctx.say("Must be in guild").await?;
        return Ok(());
    };
    let user_id = user.0;

    let level = xp::calculate_level_from_xp(xp);

    let mut user_level = ctx.data().db.get_user(user_id, guild_id).await?;
    user_level.xp = xp;
    user_level.level = level;
    ctx.data().db.update_user(&user_level, guild_id).await?;

    info!("Admin updated user {user_id} in guild {guild_id}: {xp} - {level}");

    let username = user.to_user(ctx).await?;
    ctx.say(format!("{} is now level {}", username, user_level.level))
        .await?;

    Ok(())
}

#[poise::command(prefix_command, slash_command, category = "Admin")]
pub async fn spam_delay(
    ctx: Context<'_>,
    #[description = "Delay in seconds. Leave empty to get the actual value."] value: Option<i64>,
) -> Result<(), Error> {
    let guild_id = if let Some(id) = ctx.guild_id() {
        id.0
    } else {
        ctx.say("Must be in guild").await?;
        return Ok(());
    };

    if let Some(value) = value {
        ctx.data().db.set_spam_delay(guild_id, value).await?;
    }

    let value = ctx.data().db.get_spam_delay(guild_id).await?;
    ctx.say(format!("Spam delay is set to {value} seconds."))
        .await?;

    Ok(())
}

#[poise::command(prefix_command, slash_command, category = "Admin")]
pub async fn min_xp_gain(
    ctx: Context<'_>,
    #[description = "Min xp points thaht can be gained. Leave empty to get the actual value."]
    value: Option<i64>,
) -> Result<(), Error> {
    let guild_id = if let Some(id) = ctx.guild_id() {
        id.0
    } else {
        ctx.say("Must be in guild").await?;
        return Ok(());
    };

    if let Some(value) = value {
        ctx.data().db.set_min_xp_gain(guild_id, value).await?;
    }

    let value = ctx.data().db.get_min_xp_gain(guild_id).await?;
    ctx.say(format!("Min Xp gain is set to {value} points."))
        .await?;

    Ok(())
}

#[poise::command(prefix_command, slash_command, category = "Admin")]
pub async fn max_xp_gain(
    ctx: Context<'_>,
    #[description = "Maximum xp points that can be gained. Leave empty to get the actual value."]
    value: Option<i64>,
) -> Result<(), Error> {
    let guild_id = if let Some(id) = ctx.guild_id() {
        id.0
    } else {
        ctx.say("Must be in guild").await?;
        return Ok(());
    };

    if let Some(value) = value {
        ctx.data().db.set_max_xp_gain(guild_id, value).await?;
    }
    let value = ctx.data().db.get_max_xp_gain(guild_id).await?;
    ctx.say(format!("Max Xp gain is set to {value} points."))
        .await?;

    Ok(())
}

#[poise::command(
    slash_command,
    required_permissions = "ADMINISTRATOR",
    category = "Admin"
)]
pub async fn import_mee6_levels(
    ctx: Context<'_>,
    #[description = "Json file generated by mee6-scraper"] json_file: Option<serenity::Attachment>,
) -> Result<(), Error> {
    match json_file {
        Some(file) => {
            let guild_id = ctx.guild_id().unwrap().0;

            #[derive(Debug, serde::Deserialize)]
            struct LevelJson {
                id: u64,
                level: i64,
                xp: i64,
            }

            let content = file.download().await?;
            let json: Vec<LevelJson> = serde_json::from_slice(&content)?;

            let user_levels: Vec<_> = json
                .iter()
                .enumerate()
                .map(|(i, lvl)| UserLevel {
                    user_id: lvl.id,
                    xp: lvl.xp,
                    level: lvl.level,
                    rank: i as i64 + 1,
                    last_message: 0,
                })
                .collect();

            ctx.data()
                .db
                .import_from_mee6(&user_levels, guild_id)
                .await?;
        }
        None => {
            let message = r">>> Download [mee6-scraper](https://github.com/randomairborne/mee6-scraper/).
Generate a json file from Mee6 with the command `mee6-scraper <GUILD_ID>`.
Use command /import_mee6_levels with passing the generated json file.

/!\ Actual levels stats will be overwritten!
            ";

            ctx.say(message).await?;
        }
    }

    Ok(())
}
